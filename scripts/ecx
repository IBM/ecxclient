#!/usr/bin/env python
#-*- mode: Python;-*-

import ConfigParser
import json
import os
import sys
import tempfile
import traceback

script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
root_dir = os.path.abspath(os.path.join(script_dir, ".."))
dependencies_dir = os.path.join(root_dir, "dependencies")

sys.path.insert(0, root_dir)
sys.path.insert(0, os.path.join(dependencies_dir, "click"))
sys.path.insert(0, os.path.join(dependencies_dir, "requests"))

import click
import requests
from requests.auth import HTTPBasicAuth

from util import util

class Context(object):
    def __init__(self):
        pass

class EcxSession(object):
    def __init__(self, url, username, password):
        self.url = url
        self.username = username
        self.password = password
        self.sessionid = None
        self.cfgfile = os.path.join(click.get_app_dir("ecxcli"), 'config.ini')
        self.cfgdir = os.path.dirname(self.cfgfile)
        if not os.path.exists(self.cfgdir):
            os.makedirs(self.cfgdir)

        self.conn = requests.Session()
        self.conn.verify = False
        self.conn.hooks.update({'response': util.raise_response_error})

        if self.password is None:
            self.use_existing_session()
        else:
            self.login()

        self.conn.headers.update({'X-Endeavour-Sessionid': self.sessionid})

    def use_existing_session(self):
        parser = ConfigParser.RawConfigParser()
        parser.read([self.cfgfile])

        try:
            self.sessionid = parser.get(self.username, 'sessionid')
        except ConfigParser.NoSectionError:
            raise Exception('Please provide login credentials.')

    def login(self):
        r = self.conn.post("%s/api/endeavour/session" % self.url, auth=HTTPBasicAuth(self.username, self.password))
        self.sessionid = r.json()['sessionid']
        self.save_config()

    def save_config(self):
        parser = ConfigParser.RawConfigParser()
        parser.add_section(self.username)
        parser.set(self.username, 'password', self.password)
        parser.set(self.username, 'sessionid', self.sessionid)

        parser.write(open(self.cfgfile, 'wb'))

    def __repr__(self):
        return 'EcxSession: user: %s' % self.username

pass_context = click.make_pass_decorator(Context, ensure=True)
cmd_folder = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'commands'))

class MyCLI(click.MultiCommand):
    def list_commands(self, ctx):
        rv = []
        for filename in os.listdir(cmd_folder):
            if filename.endswith('.py') and filename.startswith('cmd_'):
                rv.append(filename[4:-3])
        rv.sort()
        return rv

    def get_command(self, ctx, name):
        try:
            if sys.version_info[0] == 2:
                name = name.encode('ascii', 'replace')

            mod = __import__('commands.cmd_' + name, None, None, ['cli'])
        except ImportError:
            traceback.print_exc()
            return

        return mod.cli


@click.command(cls=MyCLI)
@click.option('--url', envvar='ECX_URL', default='http://localhost:8082', metavar='URL', help='ECX url.')
@click.option('--user', envvar='ECX_USER', default='admin', metavar='USERNAME', help='ECX user.')
@click.option('--passwd', envvar='ECX_PASSWD', default=None, metavar='PASSWORD', help='ECX password.')
@click.version_option('1.0')
@pass_context
def cli(ctx, url, user, passwd):
    """ecx is a command line tool with which ECX operations
    can be carried out.
    """

    ctx.ecx_session = EcxSession(url, user, passwd)

# cli = MyCLI(help='Script to perform ECX operations. ')

def init_logging():
    pass

if __name__ == '__main__':
    init_logging()

    try:
        cli()
    except Exception as e:
        traceback.print_exc()
        click.secho(str(e), fg='red')
        sys.exit(1)
